generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ─── REALMS ───────────────────────────────────────────────

model Realm {
  id          String  @id @default(uuid())
  name        String  @unique
  displayName String? @map("display_name")
  enabled     Boolean @default(true)

  accessTokenLifespan  Int @default(300) @map("access_token_lifespan")
  refreshTokenLifespan Int @default(1800) @map("refresh_token_lifespan")

  smtpHost     String?  @map("smtp_host")
  smtpPort     Int?     @default(587) @map("smtp_port")
  smtpUser     String?  @map("smtp_user")
  smtpPassword String?  @map("smtp_password")
  smtpFrom     String?  @map("smtp_from")
  smtpSecure   Boolean  @default(false) @map("smtp_secure")

  // Password policies
  passwordMinLength          Int     @default(8)    @map("password_min_length")
  passwordRequireUppercase   Boolean @default(false) @map("password_require_uppercase")
  passwordRequireLowercase   Boolean @default(false) @map("password_require_lowercase")
  passwordRequireDigits      Boolean @default(false) @map("password_require_digits")
  passwordRequireSpecialChars Boolean @default(false) @map("password_require_special_chars")
  passwordHistoryCount       Int     @default(0)    @map("password_history_count")
  passwordMaxAgeDays         Int     @default(0)    @map("password_max_age_days")

  // Brute force protection
  bruteForceEnabled     Boolean @default(false) @map("brute_force_enabled")
  maxLoginFailures      Int     @default(5)     @map("max_login_failures")
  lockoutDuration       Int     @default(900)   @map("lockout_duration")
  failureResetTime      Int     @default(600)   @map("failure_reset_time")
  permanentLockoutAfter Int     @default(0)     @map("permanent_lockout_after")

  // MFA
  mfaRequired Boolean @default(false) @map("mfa_required")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  users              User[]
  clients            Client[]
  roles              Role[]
  signingKeys        RealmSigningKey[]
  loginSessions      LoginSession[]
  identityProviders  IdentityProvider[]
  groups             Group[]
  passwordHistories  PasswordHistory[]
  loginFailures      LoginFailure[]

  @@map("realms")
}

// ─── USERS ────────────────────────────────────────────────

model User {
  id            String  @id @default(uuid())
  realmId       String  @map("realm_id")
  username      String
  email         String?
  emailVerified Boolean @default(false) @map("email_verified")
  firstName     String? @map("first_name")
  lastName      String? @map("last_name")
  enabled       Boolean @default(true)
  passwordHash  String? @map("password_hash")

  passwordChangedAt DateTime? @map("password_changed_at")
  lockedUntil       DateTime? @map("locked_until")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  realm               Realm               @relation(fields: [realmId], references: [id], onDelete: Cascade)
  userRoles           UserRole[]
  sessions            Session[]
  loginSessions       LoginSession[]
  consents            UserConsent[]
  federatedIdentities FederatedIdentity[]
  userGroups          UserGroup[]
  verificationTokens  VerificationToken[]
  passwordHistories   PasswordHistory[]
  loginFailures       LoginFailure[]
  userCredentials     UserCredential[]
  recoveryCodes       RecoveryCode[]

  @@unique([realmId, username])
  @@unique([realmId, email])
  @@map("users")
}

// ─── CLIENTS ──────────────────────────────────────────────

enum ClientType {
  CONFIDENTIAL
  PUBLIC
}

model Client {
  id           String     @id @default(uuid())
  realmId      String     @map("realm_id")
  clientId     String     @map("client_id")
  clientSecret String?    @map("client_secret")
  clientType   ClientType @default(CONFIDENTIAL) @map("client_type")
  name         String?
  description  String?
  enabled        Boolean    @default(true)
  requireConsent Boolean    @default(false) @map("require_consent")

  redirectUris String[] @map("redirect_uris")
  webOrigins   String[] @map("web_origins")
  grantTypes   String[] @default(["authorization_code"]) @map("grant_types")

  // Backchannel logout
  backchannelLogoutUri             String?  @map("backchannel_logout_uri")
  backchannelLogoutSessionRequired Boolean  @default(true) @map("backchannel_logout_session_required")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  realm       Realm               @relation(fields: [realmId], references: [id], onDelete: Cascade)
  clientRoles Role[]
  authCodes   AuthorizationCode[]
  consents    UserConsent[]

  @@unique([realmId, clientId])
  @@map("clients")
}

// ─── ROLES ────────────────────────────────────────────────

model Role {
  id          String  @id @default(uuid())
  realmId     String  @map("realm_id")
  clientId    String? @map("client_id")
  name        String
  description String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  realm      Realm       @relation(fields: [realmId], references: [id], onDelete: Cascade)
  client     Client?     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  userRoles  UserRole[]
  groupRoles GroupRole[]

  @@unique([realmId, clientId, name])
  @@map("roles")
}

// ─── USER-ROLE ASSIGNMENT ─────────────────────────────────

model UserRole {
  id     String @id @default(uuid())
  userId String @map("user_id")
  roleId String @map("role_id")

  assignedAt DateTime @default(now()) @map("assigned_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

// ─── SESSIONS & REFRESH TOKENS ────────────────────────────

model Session {
  id        String  @id @default(uuid())
  userId    String  @map("user_id")
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshTokens RefreshToken[]

  @@map("sessions")
}

model RefreshToken {
  id        String  @id @default(uuid())
  sessionId String  @map("session_id")
  tokenHash String  @unique @map("token_hash")
  revoked   Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

// ─── AUTHORIZATION CODES ──────────────────────────────────

model AuthorizationCode {
  id                  String  @id @default(uuid())
  code                String  @unique
  clientId            String  @map("client_id")
  userId              String  @map("user_id")
  redirectUri         String  @map("redirect_uri")
  scope               String?
  codeChallenge       String? @map("code_challenge")
  codeChallengeMethod String? @map("code_challenge_method")
  nonce               String?
  used                Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("authorization_codes")
}

// ─── REALM SIGNING KEYS ───────────────────────────────────

model RealmSigningKey {
  id        String  @id @default(uuid())
  realmId   String  @map("realm_id")
  kid       String
  algorithm String  @default("RS256")
  publicKey String  @map("public_key")
  privateKey String @map("private_key")
  active    Boolean @default(true)

  createdAt DateTime @default(now()) @map("created_at")

  realm Realm @relation(fields: [realmId], references: [id], onDelete: Cascade)

  @@unique([realmId, kid])
  @@map("realm_signing_keys")
}

// ─── LOGIN SESSIONS (browser SSO) ───────────────────────

model LoginSession {
  id        String  @id @default(uuid())
  userId    String  @map("user_id")
  realmId   String  @map("realm_id")
  tokenHash String  @unique @map("token_hash")
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  realm Realm @relation(fields: [realmId], references: [id], onDelete: Cascade)

  @@map("login_sessions")
}

// ─── USER CONSENT ────────────────────────────────────────

model UserConsent {
  id       String   @id @default(uuid())
  userId   String   @map("user_id")
  clientId String   @map("client_id")
  scopes   String[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([userId, clientId])
  @@map("user_consents")
}

// ─── GROUPS ─────────────────────────────────────────────

model Group {
  id          String  @id @default(uuid())
  realmId     String  @map("realm_id")
  name        String
  description String?
  parentId    String? @map("parent_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  realm      Realm       @relation(fields: [realmId], references: [id], onDelete: Cascade)
  parent     Group?      @relation("GroupHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children   Group[]     @relation("GroupHierarchy")
  userGroups UserGroup[]
  groupRoles GroupRole[]

  @@unique([realmId, name])
  @@map("groups")
}

model UserGroup {
  id      String @id @default(uuid())
  userId  String @map("user_id")
  groupId String @map("group_id")

  assignedAt DateTime @default(now()) @map("assigned_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("user_groups")
}

model GroupRole {
  id      String @id @default(uuid())
  groupId String @map("group_id")
  roleId  String @map("role_id")

  assignedAt DateTime @default(now()) @map("assigned_at")

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  role  Role  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([groupId, roleId])
  @@map("group_roles")
}

// ─── VERIFICATION TOKENS ────────────────────────────────

model VerificationToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique @map("token_hash")
  userId    String   @map("user_id")
  type      String   // "email_verification" | "password_reset"
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verification_tokens")
}

// ─── PASSWORD HISTORY ────────────────────────────────────

model PasswordHistory {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  realmId      String   @map("realm_id")
  passwordHash String   @map("password_hash")
  createdAt    DateTime @default(now()) @map("created_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  realm Realm @relation(fields: [realmId], references: [id], onDelete: Cascade)

  @@map("password_histories")
}

// ─── LOGIN FAILURES (brute force) ────────────────────────

model LoginFailure {
  id        String   @id @default(uuid())
  realmId   String   @map("realm_id")
  userId    String?  @map("user_id")
  ipAddress String?  @map("ip_address")
  failedAt  DateTime @default(now()) @map("failed_at")

  realm Realm @relation(fields: [realmId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([realmId, userId, failedAt])
  @@map("login_failures")
}

// ─── MFA / TOTP ──────────────────────────────────────────

model UserCredential {
  id        String  @id @default(uuid())
  userId    String  @map("user_id")
  type      String  @default("totp")
  secretKey String  @map("secret_key")
  algorithm String  @default("SHA1")
  digits    Int     @default(6)
  period    Int     @default(30)
  verified  Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@map("user_credentials")
}

model RecoveryCode {
  id       String  @id @default(uuid())
  userId   String  @map("user_id")
  codeHash String  @map("code_hash")
  used     Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("recovery_codes")
}

// ─── IDENTITY PROVIDERS (Social Login) ───────────────────

model IdentityProvider {
  id            String  @id @default(uuid())
  realmId       String  @map("realm_id")
  alias         String
  displayName   String? @map("display_name")
  enabled       Boolean @default(true)
  providerType  String  @default("oidc") @map("provider_type")

  clientId         String  @map("idp_client_id")
  clientSecret     String  @map("idp_client_secret")
  authorizationUrl String  @map("authorization_url")
  tokenUrl         String  @map("token_url")
  userinfoUrl      String? @map("userinfo_url")
  jwksUrl          String? @map("jwks_url")
  issuer           String?

  defaultScopes    String @default("openid email profile") @map("default_scopes")
  trustEmail       Boolean @default(false) @map("trust_email")
  linkOnly         Boolean @default(false) @map("link_only")
  syncUserProfile  Boolean @default(true)  @map("sync_user_profile")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  realm               Realm               @relation(fields: [realmId], references: [id], onDelete: Cascade)
  federatedIdentities FederatedIdentity[]

  @@unique([realmId, alias])
  @@map("identity_providers")
}

// ─── FEDERATED IDENTITIES ────────────────────────────────

model FederatedIdentity {
  id                 String  @id @default(uuid())
  userId             String  @map("user_id")
  identityProviderId String  @map("identity_provider_id")
  externalUserId     String  @map("external_user_id")
  externalUsername   String? @map("external_username")
  externalEmail      String? @map("external_email")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  identityProvider IdentityProvider @relation(fields: [identityProviderId], references: [id], onDelete: Cascade)

  @@unique([identityProviderId, externalUserId])
  @@unique([userId, identityProviderId])
  @@map("federated_identities")
}
